# leetcode 刷题

## 2020.5.27

#### NO.1 两数之和 easy 数组

#### NO.2 两数相加 mid 链表

#### N0.7 整数反转 easy  数学

#### N0.20 有效括号 easy 栈 字符串

栈是在表尾进行插入和删除操作的线性表。进行插入和删除操作的称为栈顶，表头为栈底。

队列是在表的前端进行删除操作，在表的后端插入元素。进行删除操作的称为队头，进行

插入操作的称为队尾。

## 2020.5.28

#### NO.21 合并两个有序列表 easy

#### NO.83 删除排序列表中的重复元素 easy

## 2020.5.29

#### NO.141 环形列表 easy 快慢指针追逐法 哈希表查询法

#### NO.225 用队列实现栈 easy

#### NO.206 反转链表 

## 2020.5.30

#### NO.976 三角形最大周长 easy

 对数组进行降序排序，从开始选三个元素就符合了三角形a>b>=c的原则，再查看是否满足a<b+c的条件，若不满足，则a往后遍历。

#### NO.9 回文数 easy

## 2020.6.1 

#### NO.1431 拥有最多糖果的孩子 easy

## 2020.5.31

#### NO.26 删除排序数组中的重复项 easy 时间复杂度低解法

len_new为改后数组索引，遍历数组，若下一个元素与该元素不同，则nums[len_new]赋值，len_new+1，若不同，则继续遍历，直到遇到不同元素，对len_new进行赋值。该方法在没有使用额外空间的情况下，利用新的索引，创造了新的虚拟数组。

#### NO.38 外观数列 easy 60mins

#### NO.443 压缩字符串 easy

这道题和NO.26很相似，都是涉及到原地算法。原地算法要求算法不使用除了输入以外的空间进行操作，只能原地进行数组修改。所以只能用“指针”，即列表中的索引进行处理。通过anchor指针来指向每一字符块的起点，用read指针指向当前迭代指向的元素，用write来指向改写数组的位置。当read指针对应的元素处于字符块终点，则用write指针写入当前元素，写完一次write就往后指一个位置，并通过read - anchor + 1来计算字符块大小，并用write将大小写入数组。

## 2020.6.3

### 时间复杂度

是指执行当前算法所消耗的时间

时间复杂度公式：$T(n)=O(f(n))$

$f(n)$表示每行代码执行次数之和，而$O$表示正比例关系，这个公式的全称是：**算法的渐进时间复杂度**，用来表示代码执行时间的增长变化趋势。

常见的时间复杂度量级有：

- 常数阶O(1)

  无论代码执行了多少行，只要是没有循环结构，这个代码的时间复杂度就都是$O(1)$。

- 对数阶O(logN)

  ```c++
  int i = 1;
  while(i<n)
  {
      i = i * 2;
  }
  ```

  循环将会执行到$i>2^{n}$才会停止，则循环的次数x为$x=log(2^{n})$，则代码的时间复杂度为：$O(logn)$

- 线性阶O(n)

  ```c++
  for(i=1; i<=n; ++i)
  {
     j = i;
     j++;
  }
  ```

  这段代码中，for循环里面的代码会执行n遍，因此它消耗的时间是随着n变化而变化的。

- 线性对数阶O(nlogN)

  就是将时间复杂度为$O(logn)$的代码循环N遍

- 平方阶O(n²)

  将$O(n)$的代码再嵌套循环一遍，时间复杂度就是$O(n^{2})$

- 立方阶O(n³)

  三层循环

- K次方阶O(n^k)

  k层循环

- 指数阶(2^n)

### 空间复杂度

是指执行当前算法需要占用多少内存空间

计算算法在运行过程中临时占用存储空间大小的一个度量

- $O(1)$

  代码中所占用的空间不随着处理数据的过程中变化，因此其空间复杂度为$O(1)$

- $O(n)$

  ```c
  int[] m = new int[n]
  for(i=1; i<=n; ++i)
  {
     j = i;
     j++;
  }
  ```

  一开始分配了大小为n的数组

NO.28 实现strStr() easy

## 2020.6.5

#### NO.19 删除链表的倒数第N个节点 med

- 方法1：利用list从存储列表内容，再利用list.pop()删除内容，再将list内容赋值给链表。

（注意：有链表大小只有1，或者要删除头节点，则应该在头节点前设置哑节点）

- 方法2：不需要另外内存空间放列表，直接操作链表。

先遍历一次链表获得链表长度L，再遍历一次链表直到指针指到第L-N个结点，将该节点的next指向下下个节点，就完成了删除任务。

（注意：有些链表大小只有1，或者要删除头节点，则应该在头节点前设置哑节点）

#### NO.13 罗马数字转整数 easy

这道题最主要的思维是要发现罗马数字的规律。某一个字符和下一个字符的关系有两种，一种是该字符大于下一个字符，这是正常情况，只需要简单加上该字符的值就可以；另一种是该字符小于下一个字符，则加上的数值应该是下一个字符的值减去该字符的值。

则代码只需要遍历数组，判断当前字符和下一个字符的关系来决定要加的数值。

#### NO.27 移除元素 easy

#### NO.203 移除链表元素 easy

算法：

- 初始化哨兵节点为 ListNode(0) 且设置 sentinel.next = head。
- 初始化两个指针 curr 和 prev 指向当前节点和前继节点。
- 当 curr != nullptr：
  - 比较当前节点和要删除的节点：
    - 若当前节点就是要删除的节点：则 prev.next = curr.next。
    - 否则设 prve = curr。
  - 遍历下一个元素：curr = curr.next。
- 返回 sentinel.next。



## 2020.7.2

#### NO.82 删除排序列表中的重复元素II medium

利用前后两个指针，前面的指针用来检测重复元素，后面的指针负责删除所有重复元素。

#### NO.234 回文列表 easy

部分逆序法：利用快慢指针找到链表的中点，然后从中点对链表的后半部分进行逆序，最后将这个逆序与链表前半部分进行逐一对比，查看是否一致。

栈方法：将元素一一入栈，再让元素一一出栈，比较两个序列。



## 2020.7.6 

#### NO.24 两两交换链表中的节点 medium

输入：1 → 2 → 3 → 4      输出：2 → 1 → 4 → 3 

递归方法：
先将方法抽象化，A为交换两元素的第一个元素，B为第二个，若要完成交换的过程，则A首先指向已经完成交换的新链表的表头，B指向A，这就完成了一次交换。

```python
first.next = swapPairs(second.next) 
second.next = first
```

#### NO.1608 面试题 删除中间节点 easy



## 2020.7.8

#### NO.445 两数相加II medium

先将链表进行倒序，再进行带进位的逐位相加，然后再每次计算结果倒序存储。

#### NO.67 二进制求和 easy

#### NO.387 字符串中的第一个唯一字符 easy



## 2020.7.9

#### NO.415 字符串相加 easy

#### NO.58 最后一个单词的长度 easy



## 2020.7.11

#### NO.151 翻转字符串中的单词 medium

双解法，一种语言API直接暴力解法

另一种是堆栈法

#### NO.88 合并两个有序数组 easy

将p1p2分别指向两个数组的有效末端，并且将p指向合并数组的有效末端。

比较p1和p2指向的值，p的值等于两者较大值。这样从大到小，从列表尾部向头部，逐个降序插入元素。最后p1p2任意一个指针到头，都会结束迭代。最后将nums2数组剩下未被访问的元素，放到nums1的数组最开头的位置。因为如果nums2还剩下元素未被访问，则说明此时nums1的元素已经放置完毕，剩下的空位正是留给nums2剩下的元素。

这个解法真的很巧。

#### NO.1160 拼写单词 easy

#### 剑指offer53. 0~1中缺失的数字 easy



## 2020.7.13

#### NO.242 有效的字母异位词 easy 13mins

#### NO.35 搜索插入位置 easy 11mins

## 2020.7.16

#### NO.349 两个数组的交集 easy

## 2020.7.17

#### NO.136 只出现一次的数字 easy

#### NO.160 相交链表 easy

## 2020.7.20

#### NO.237 删除链表中的节点 easy

#### NO.206 反转链表  easy

#### 面试题 02.01 移除重复节点 easy

## 2020.7.22

#### NO.86 分隔链表 medium

#### NO.101 高度检查器 easy

## 2020.7.23

#### NO.217 存在重复元素 easy

## 2020.7.24

#### 面试题 02.07 链表相交 easy

题目中的链表是无环的，则无环链表相交情况只有一种：

1  →  2  →   3 → 8

5  →  5  → 4 ↑

即开头无重复节点，从相交处开始，共用节点，一直到最后。

首先，遍历两个链表，使得指针一直直到最后节点，如果两个节点不一样，则说明不相交，同时记录两个链表长度。

若相交，则长的链表开始指针往前走 长度差 个节点，然后两个链表节点开始往下走，走到相同节点就是相交节点。



#### NO.138 复制带随机指针列表 medium

两种方法：

①哈希表：空间复杂度0(N) 笔试用

遍历老链表，建立哈希表，key是老链表节点，value是新链表节点，建立起新老节点对应的关系

再次遍历老链表，或者遍历哈希表，设置新节点的random指针，新节点random指针是通过老节点的random指针指向的老节点对应的新节点来确定的；设置新节点的next指针，新节点的next指针是通过老节点的next指针指向的老节点对应的新节点来确定的。

②级联新旧节点：空间复杂度O(1) 面试用

级联新旧节点，方式是，将新节点插入到对应老节点的后面，类似于：

老1 → 新1 → 老2 → 新2 → None

老节点通过next指针找到对应新的节点，这样就代替了哈希表的mapping作用。

这时候，要先设置random再设置next，两步在不同循环，因为在random还没有全部设置好的情况下，改动next指针将会破坏这种新老对应关系。

先设置random指针，新节点的random指针是通过老节点的random指针指向的老节点对应的新节点来确定的。

再设置next指针，新节点的next指针就是它的下下个节点。



## 2020.7.25

#### NO.102 二叉树的层序遍历 medium

广度优先遍历，即二叉树从根节点从上往下从左往右逐层遍历，并且逐层存储节点值。

这就用到队列。

设置哈希表，key是节点，value是节点所在层

首先将头节点入队列；

然后进入循环：

{弹出一个节点；

先后将该节点的左孩子和右孩子入队列；

判断该节点是否为某层第一个节点，若是，则结算上层节点，即，将上层所有节点列表写入总列表

若不是，则将该节点写入该层节点列表

}



#### NO.662 二叉树最大宽度 medium

#### 面试题04.04 检查平衡性 easy

#### NO.662 二叉树最大宽度 medium

#### NO.958 二叉树的完全性检验medium

#### NO700 . 二叉搜索树中的搜索 easy

#### NO.102 二叉树的层序遍历 medium



## 2020.8.5 

#### NO.208 实现前缀树 med

#### NO.125 验证回文串 easy

#### NO.110 平衡二叉树 easy

#### NO.51 N皇后 hard



## 2020.8.6 

#### 剑指Offer 41 数据流中的中位数 hard

该方法用到了两个堆，一个大根堆，一个小根堆。

利用大根堆来接收数据流较小的数字，小根堆接受数据流中较大的数字，同时保持大小根堆的大小差值不为1，这样就能保证中位数保持在大根堆或小根堆的堆头。

具体做法是：

把第一个数字放入大根堆。

加入一个数字的操作：

1.查看这个数字于大根堆堆头大小关系（也可以是小根堆，只要初始化的时候把数字放在小根堆就行），大于堆头，数字放小根堆，小于等于堆头，数字放大根堆

2.修正大根堆小根堆大小，若其中一方的尺寸比另一边大2，则把起堆头弹出送到另一边。

如何查看当前数据流的中位数：

判断大根堆小根堆的大小关系：
①两个堆相同，则已输入数据量为偶数，中位数为两个堆的头的平均值；

②大根堆大1，则中位数为大根堆堆头

③小根堆大1，则中位数为小根堆堆头



#### NO.23 合并K个排序链表 hard

这道题就可以使用归并排序的思想。

K个链表可以由两个K/2个链表合并，其中K/2个链表又可以由两个K/4个链表合并。这样分割递归的base case是当分到只有两个链表，开始通过归并将两个链表合并起来。

合并两个链表需要申请额外空间生成新的链表，具体的做法是：

①分别用两个指针分别指向两个链表的表头，两个指针代表了链表的当前节点；

②对比两个指针的节点大小，较小的那个值送到新的链表中。链表中每取走一个值，指针都往后走一格；

③周而复始，总有一边指针会指到尾部，此时再把另一边的剩余部分补充到新链表中，就完成了归并。

#### NO.94 二叉树的中序遍历 med

这道题利用了递归算法解决。

中序遍历是对于一棵树，先访问左子树的节点，再访问根节点，最后访问右子树的节点。

那么来到一个节点，则先访问这个节点的左子树，将遍历结果加入res列表，访问完左子树，再加入当前节点的值到结果中，最后再访问右子树。

base case是当前节点为空，则不执行语句直接返回。



## 2020.8.7

#### NO297.二叉树的序列化与反序列化 hard

二叉树的序列化是指将二叉树的节点值按照一定顺序转化为字符串；

二叉树的反序列化是将字符串按照一定规则转化为二叉树。

这道题中所要求的序列是二叉树的层序遍历，涉及到二叉树的层序遍历，那就一定要用到队列，先进先出。

**二叉树序列化**层序遍历的算法如下：

①加入树的根节点到队列

循环 （当队列不为空）：

②从队列中弹出一个节点；

③进行相应处理，可以是打印，或者加入结果列表，本题是将值加入字符串中；

③若有，先后将左右孩子放入队列中（到时候会先访问左孩子，因为左孩子先放）

循环结束

**二叉树反序列化**

①取字符串第一个值为头节点，将头节点加入队列；设置i指向第二个字符

*循环（队列不为空）*：

②从队列中弹出一个节点，为当前节点；

③判断i是否是有效值，若是，则该值是当前节点的左孩子，并将左孩子加入队列；

④i往后移一位，因为字符串该位置已经检测过了；

⑤判断i是否是有效值，若是，则该值是当前节点的右孩子，并将右孩子加入队列；

⑥i往后移一位

*循环结束*

#### NO.43 字符串相乘 med

#### NO.104 二叉树的最大深度 easy

**二叉树的深度**是层次最深的叶子节点距离根节点的最短距离。

这是一个可以利用算法课中的递归思维解题。

就是**根节点可以分别从左右子树中获取信息，来计算所需要的结果**。

这道题，对于根节点，其深度就是**左树最大深度和右树最大深度中的最大值加1**。

则，根节点找左右子树要的信息就是最大深度。

**base case**: 当前节点为空，则返回0，因为空节点的深度为0。

#### NO.111 二叉树的最小深度 easy

与上一道题有些类似，这里是求最小深度。

根节点的深度等于**左树最小深度和右数最小深度的最小值加1**。本题中的当前节点会出现几种情况：

- 当左右孩子有一个为空时，最小深度不应该是0加1，还是不为空的那个孩子的深度加1
- 当左右孩子都在，返回最小的那个加1
- 当左右孩子都没有，返回1

**base case**：当一个节点为空时，返回0

#### 剑指Offer 17 打印1到最大的n位数 easy

#### NO.202 快乐数 easy

## 2020.8.9

#### NO.8 字符串转换整数 med

#### 剑指Offer 38 字符串的排列 med

采用**回溯法**解决该问题。

这是经典的排列问题，求字符串所有可能不重复的排列。

对于每一位字符位，每次不重复地选字符集合里的其中一个，下一位字符则跟字符串剩余部分的每个字符进行交换，交换一次，继续递归下一位，递归到最后得到最终结果，加入res列表。

为了保证每一位选的字符不重复，我们采用了集合visit来确定哪些元素也被选中过不能再选，以免重复，也就是剪枝操作。

~~~python
string = 'abc'
def permuation(string):#主函数
    result = []
    if len(string) == 0:
        return result
    process(0, string, result)
    return result

def process(i, string, result):#递归函数
    '''
    string是当前排列，与原字符串不一样，当得到当前的排列结果，并且将排列结果存到结果列表result中后，string就恢复原来的样子
    '''
    if i == len(string):# base case:当遍历完整个字符串，则应该结算排列结果
        result.append(string)
        return
    visit = set()
    for j in range(len(string)):#此时string[:i]已经选定，对于字符串的第i个位置，其取值可以是string[i:]的每个字符，所以每次循环就将后面字符串切片中的每个不重复字符与第i个位置的字符进行交换。每个字符交换过后，就加入visit集合，防止有重复字符放在第i个位置上，导致结果重复。
        if strqing[j] not in visit:
            visit.add(string[j])
            string[i], string[j] = string[j], string[i]#交换后继续计算下一个字符
            process(i + 1, string, result)
            string[i], string[j] = string[j], string[i]#计算完后，恢复字符串，以进行下一个循环
~~~



#### NO.78 子集 med 

采用**回溯法**解决该问题。

这是经典的组合问题，这个相比于排列要更为简单一些。

遍历字符串，到达某个字符时，选择是否将该字符加入当前组合，加入是一个选择，不加入是另一个选择，递归遍历所有字符，当递归到最后一个字符之后，将当前组合结果加入res列表。

换句话说，每到一个字符，都有两条路可以选择，最后相当于把所有路径都给保存起来了。

~~~python
def subsets(string):#主函数
    result = []
    if len(string):
        return result
    subset = ''
    process(0, string, subset, result)
    return result

def process(i, string, subset, result):
    if i == len(string):
        result.append(subset)
        return
    process(i + 1, subset + string[i], result)
    process(i + 1, subset, result)
    
~~~



#### NO.47 全排列II med

## 2020.8.10

#### NO.50 Pow(x, n)

采用**二分法**来求解。

x的n次幂，是对x进行平方，再对其结果进行平方，周而复始，直到求到n次方。这样计算量就少了许多，不需要每一次只乘一次x，原来是O(N)，现在是O(logn)。

**算法**：

递归函数**mul**(x, N)

**base case：**当N = 0，则返回1，因为任何数的0次幂都是1。

当N为偶数时，x的N次幂等于x的N/2次幂 * x的N/2次幂；

当N为奇数时，x的N次幂等于x的N//2次幂 * x的N//2次幂 * x

~~~python
def mul(x, N):
    if N == 0:
        return 1
    y = mul(x, N//2)
    if N % 2 == 0:
        return y * y
    else:
        return y * y * x
~~~

主函数**pow**(x, n)：

当N为正数，正常返回，当N为负数，返回其正数次幂的倒数

~~~python
def pow(x,n):
	return mul(x,n) if N>=0 else 1/(mul(x, -n))
~~~

#### 面试题 16.07 最大数值 easy

找出两个数字的最大值，不能使用条件语句，也不能使用比较符号。

这里运用了一个数学公式：

$max(a,b) = (|a -b|+a+b)/2$

#### NO.367 有效的完全平方数 easy

采用**二分法**来求解这道题。

对于一个正整数n，若要证明其是有效的完全平方数，则要在小于n范围内找到一个正整数x，使得x^2^=n。所以这道题变成从1~n范围内寻找一个数x。

若用传统的方法，则会逐个遍历每一个数来判断。这里可以采用二分法来把搜索的时间复杂度从O(N)变成O(logN)，其算法如下：
①确定寻找范围的左右边界；

②计算中点位置，并判断中点位置是否符合要求，若中点数字的平方＞n，则需要在中点左侧继续搜索，若中点数字平方＜n，则需要在中点右侧继续寻找，周而复始；

③遍历完没有发现符合的数字，则不是有效的完全平方数。

#### 面试题 17.06 2出现的次数 med

传统方法：遍历0-n每个数字，累加2的个数。当n特别大时，计算时间太久会超时。

新方法：不需要遍历每个数字，直接对数字n进行分析，对每一位可能出现2的次数进行累加，就得到了整个2出现的次数。比如，分别求个、十、百、千中出现2的次数。

对于数字22，个位出现2的数字有：2，12，22；十位出现2的数字有：20，21，22

一共出现了6次2。

对于数字12X12，百位2出现的次数如何计算？

- 当X>2时，百位出现2的次数只取决于更高位数字，**11**200-**11**299, **10**200-**10**299,..., **00**200~**00**299，出现了十二段100次2，也就是12×100=1200，则出现了（高位数）*100（**10^低位位数^**）次，；

- 当X = 2时，不仅有上述的出现2的次数，还有一部分是12开头的，即，12200-12212一共13个数字在百位出现2，则还需要在12*100的基础上加上低位数字（12 + 1），1200 + 13
- 当X > 2时，则12开头的数字有100个，即12200-12299，所以是13*100= 130

算法的写法：

遍历每一个位数，通过其高位和低位数字来算出2出现的个数，然后对结果进行累加。

#### NO.70 爬楼梯 easy

可以使用回溯法来解决，即每到一层台阶就有两个选择，一个是走一个台阶，另一个是走两节台阶。

但是当层数很多之后，程序递归次数太多，运行时间很慢，因为需要逐层去处理，**并且递归有很多重复计算**。

这里可以用**滚动数组的思想**来解决这道题。

$f(x) = f(x-1)+f(x-2)$

n层台阶的走法，等于n-1层台阶的走法加上n-2层台阶走法的和。

那我们分别设置3个变量来代表n，n-1，n-2层的走法，然后通过迭代一直更新这三个变量，迭代n次，就得到了最终的n层台阶的走法。

**这道题滚动数组实际上就是动态规划方法，但是不同的地方是，动态规划一般使用数组保存状态，但是该方法只用到了三个变量，这实际上是对动态规划的状态压缩的一个优化技巧。**

**如果用动态规划，就可以建立一个大小为N的数组f[N]，f[i]代表爬i阶楼梯的方法总数，则状态方程为f[i] = f[i-1] + f[i-2]。实际上，我们发现，在计算的过程中，f[i]只需要计算前两个值，再往前的算过一次就不需要了，所以这里也没必要使用一个数组把所有状态都保存下来，只要要用三个变量，就把三个状态保存下来，每次计算都向前更新状态。**

~~~python
def climbStairs(n):
    p = 0#初始化最初状态为0
    q = 0#初始化第0层台阶走法为0，因为此时还没有开始迭代，则q保存的实际上是第0层的走法，为0
    r = 1#初始化第1层台阶走法为1，r保存的实际上是第1层的走法，为1
    for i in range(n):#迭代n次，第一次迭代r在第1层，第n次迭代r是第n层
        p = q #i - 2的状态
        q = r #i - 1的状态
        r = p + q #i的状态等于前两者之和
return r
~~~

#### NO.73 矩阵置零 med

#### NO.40 组合总和II med

#### NO.77 组合 med

#### NO.46 全排列 med 



## 2020.8.11

#### NO.824 山羊拉丁文 easy

#### NO.434 字符串中的单词数 easy

#### NO.1455 检查单词是否为句中其他单词的前缀 easy

#### NO.703 数据流中的第K大元素 easy

使用**堆**来解决该问题。

建立一个小根堆，始终保持小根堆大小为K，这样小根堆的堆顶始终是当前数据流的第K大元素。

## 2020.8.12

#### LCP.06 拿硬币 easy

#### NO.62 不同路径 med

**动态规划**的计数型题目，要计算不同路径的数量。

首先需要把动态规划的问题模型缩小，变成子问题。

该题目求到(m,n)点的路径数，则在到(m,n)点之前只有两种状态，一是机器人在(m,n-1)另一种是(m-1,n)，这时候到(m,n)点的路径数等于到(m,n-1)路径数加上到(m-1,n)路径数，这时候已经把问题规模缩小了，得到了子问题。

所以本题的状态应当是：**f(i,j) 为到点(i,j)的路径数，f(i,j) = f(i-1,j) + f(i,j-1)**

代码：

~~~python
def uniquePaths(m, n):
    #建立动态规划数组
    dp = [[0 for i in range(n)] for j in range(m)]
    #提供初始状态
    dp[0][0] = 0
    #计算状态
    for i in range(m):
        for j in range(n):
            if j > 0:#当在不在第一列
                dp[i][j] = dp[i][j-1]
            if i > 0:#当不在第一行
                dp[i][j] = dp[i-1][j]
    return dp[m-1][n-1]
~~~

## 2020.8.13

#### NO.55 跳跃游戏 med

这道题可以用**动态规划、贪心算法**求解。

先说如何使用动态规划求解。这个一个**求存在**的类型，因为题目中问是否能够到达。则我们的状态数组元素一定时bool值。

状态数组：**dp(i)代表能否到达数组的位置**

状态转移方程：$$j∈[0, i-1] dp[i] = dp[j] and (j + a[j] >= i)$$

意思是如果$$[0,i-1]$$位置上，若存在位置j能够跳到位置i，并且位置j也是能跳到的，那么位置i也能够跳到。

代码：

~~~python
def junpgame(arr):
    n = len(arr)
    #建立状态数组
    dp = [False] * n
    #提供初始状态
    dp[0] = True
    #计算状态
    for i in range(1, n):
        for j in range(i):
            if dp[j] and j + a[j] >= i:
                dp[i] = True
                break
	return dp[n-1]
~~~

该方法在leetcode超出了时间限制，因为有些测试用例数组arr真的很大，所以我们应该考虑另一种算法，**贪心算法**。

贪心算法原理很简单，遍历数组中的每个数，每访问到一个元素，就计算该元素能够达到的最远距离，并更新当前所能达到的最远距离，最后计算处的最远距离若大于数组长度，则说明能够到达。

#### NO.322 零钱兑换 med

**动态规划**

假设有三种硬币2, 3, 5，目标金额为27

确定状态：f[i] = **当总金额为i时，所需要最少的硬币数**

最后一步：在选择最后一枚硬币时，总金额为amount - 当前硬币的面值，对应的硬币数为最终的最少硬币数减1，由于最后一枚硬币有三种选择，则最终答案应为三种选择的最小值。

$f[27] =  min(f[27 - 2] + 1, f[27 - 3] + 1, f[27 - 5] + 1)$

状态转移方程：$$f[i] = min(f[i - 2] + 1, f[i - 3] + 1, f[i - 5] + 1)$$

代码：

~~~python
import sys
def coinChange(coins, amount):
    #建立状态数组
    dp = [sys.maxsize] * (amount + 1)
    #提供初始状态
    dp[0] = 0 #凑出0元只需要0枚硬币
    #计算状态
    for i in range(1, n+1):
        for j in range(len(coins)):
            if i - coins[j] >= 0 and dp[i - coins[j]] != sys.maxsize:
                dp[i] = min(dp[i], dp[i - coins[j]] + 1)
    if dp[amount] == sys.maxsize:
        res = -1
    else:
        res = dp[amount]
    return res
~~~

#### NO.518 零钱兑换II med 

这个问题属于完全背包问题的变种，利用**动态规划**解题。

该题目与上一题不同，上一题是求解最小值，这一题是在计数。

首先得确定题目的状态，背包问题种题目一般不止一个状态，**组成的不同面额**一定是一个状态，然后另一个是**使用了前几种硬币**。因为实际上，根据题目的条件，使用不同的硬币组合，组合方法不同，所以**选择使用哪些硬币**也是一个状态。

据此，本题有两个状态，**dp(i, j)代表使用前i种硬币的情况下，凑成金额j的方法数**。

状态转移方程：对于第i种硬币，可以选择，也可以不选择

- 若选择第i种硬币，则只需要**如何用i种硬币凑出$j - coins[i]$**，即，**$dp(i, j - coins[i])$**
- 若选择不使用第i种硬币，则直接继承$$dp(i-1,j)$$，即用前i - 1种硬币凑出j元

所以，$$dp(i,j)$$应为上述两者之和

$dp(i,j) = dp(i, j-coins[i]) + dp(i -1,j)$

我们可以看出状态i只和状态i -1 以及状态 i有关，所以这一维状态可以优化省去。

代码：

~~~python
def coinChange1(coins, amount):#原版二维状态数组
    dp = [[0 for i in range(amount + 1)] for j in range(len(coins) + 1)]
    #数额从0 ~ amount，使用的硬币种类数0 ~ len(coins)
    dp[0][0] = 1 #用前0种硬币组成0元的方法只有一种
    for i in range(1, len(coins) + 1):
        dp[i][0] = 1 #用前i种硬币组成0元的方法只有一种
        for j in range(1,amount + 1):
            if j - coins[i - 1] >= 0:
                dp[i][j] = dp[i][j - coins[i - 1]] + dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]
	return dp[len(coins)][amount]

def coinChange2(coins, amount):#优化版一维状态数组
        #优化版本
        dp = [0] * (amount + 1)
        dp[0] = 1
        for i in range(len(coins)):
            for j in range(1, amount + 1):
                if j - coins[i] >= 0:
                    dp[j] += dp[j - coins[i]] 
                    #此时的dp[j - coins[i]]是上一个状态(i-1)的值]
                    #没有else，就代表第i个状态直接继承了i-1的状态，即dp[j]不变
        return dp[amount]    
~~~

## 2020.8.14

#### NO.746 使用最小花费爬楼梯 easy

#### NO.53 最大子序和 easy

**动态规划**

本题只有一个状态量，即数组的前i个元素的最大子序和dp[i]，若遍历到第i个元素，前i-1个元素种最大子序和为x，有两种选择，一是若将i加入该子序，则形成一个子序和，若i不加入该子序，则i自成一个子序，比较二者大小，更大的那个为dp[i]的值。

状态转移方程为：

$dp[i] = max(dp[i-1]+nums[i], nums[i])$

代码：

~~~python
def maxSubArray1(nums):
    n = len(nums)
    dp = [0] * (n + 1)
    for i in range(1,n + 1):
        dp[i] = max(dp[i - 1] + nums[i - 1], nums[i])
    return max(dp)
#优化版本
def maxSubArray2(nums):
    n = len(nums)
    dp_prev, dp_cur, res = 0, 0, 0
    for i in range(1,n + 1):
        dp_cur = max(dp_prev + nums[i - 1], nums[i])
        dp_prev = dp_cur
        res = max(res, dp_cur)
    return res
~~~

#### NO.215 数组中的第K个最大元素 med

**堆方法**

对数组进行heapify，将数组变成大根堆，循环k次，每次弹出根节点，最后一个弹出的就是第K大的元素。

**partition方法**



#### NO.347 前K个高频元素 med

#### NO.100 相同的树 easy

对于两棵树来说，要想相等，两个结点值首先要相等，其次两棵树的左子树相等，且右子树也相等，则根节点向左右子树要信息。

base case：

- 两个根节点皆为空，则相等

- 两个根节点只有一个为空，则不相等
- 两个根节点值不同，则不相等

~~~python
def isSameTree(root1, root2):
    if not root1 and not root2:#两个根节点皆为空，则相等
        return True
    if not root1 or not root2:#两个根节点只有一个为空，则不相等
        return False
    if root1.val != root2.val:#两个根节点值不同，则不相等
        return False
    #若两个节点都不为空，且节点值都相等，则比较其左右子树
    return isSameTree(root1.left, root2.left) and isSameTree(root1.right, root2.right)
~~~

#### 面试题 16.11 跳水板 easy

## 2020.8.15

#### NO.139 单词拆分 med

利用**动态规划**解题，是存在型题目，即判断能否进行单词拆分。

状态变量只有一个，即，**前i个字母**dp[i]，代表前i个字母组成的字符串能够进行单词拆分。

则对于dp[i]，就要对s[:i]进行分割处理，s[:i]分成s[:j]以及s[j:i]，其中，s[:j]能否有效拆分已经计算过，为dp[j]，则只需要判断s[i:j]这段字符串是否为字典里的单词即可。

为什么要将s[:i]一分为二而不是分成三份或者四份呢？

因为要考虑确定某一个状态则一定要参考该状态的前面的某个状态，即dp[j]，dp[j]又代表了前j个字母能否进行单词拆分，若能，里面可能包含了多个有效单词。所以，若剩下的s[j:i]也是一个单独的有效单词，则s[:i]就能够进行单词拆分。

优化方法：

我们实际上在考察s[j:i]是否存在，则当s[j:i]长度非法时，即短于字典中最短的单词

状态转移方程：

**dp[i]=dp[j] and s[j:i] in wordDict​**

~~~python
import sys
def wordBreak(s, wordDict):
    n = len(s)
    #首先计算字典中单词长度的最值
    maxlen, minlen = 0, sys.maxsize
    for word in wordDict:
        maxlen, minlen = max(maxlen, len(word)), min(minlen, len(word))
    #建立状态数组
    dp = [False] * (n + 1)
    dp[0] = True #主要是为了寻找s中的第一个单词用的，因为一开始分割只能是分成''和s[0:i],dp[0]必须为True，不然无法计算
    #计算状态
    for i in range(1, n + 1):
        if i < minlen:#进行剪枝，因为此时不可能分割单词
            continue
        for j in range(max(i - maxlen, 0), i - minlen + 1):
            #保证长度有效
            if dp[j] and s[j:i] in wordDict:
                dp[i] = True
                break
	return dp[n]
~~~

#### 2020.8.16 有序矩阵中第K小的元素 med

题目中的矩阵有如下特征：

- 每行元素都是升序排列
- 每列元素都是升序排列

本题可以采用二分法进行搜索，首先计算中间值mid，计数比mid小的数有几个，若数量大于k，则说明mid数值偏大，需要选择更小mid数值，若数量比k小，说明mid数值偏小，需要取更大的mid来增加小于该数的元素数量。周而复始，一直到把搜索范围缩小到一个数时，该数就是第k小的元素。

二分法的思想是如此，但是如何进行计数呢？需要从第一行开始逐元素搜索吗？

由于矩阵的上述特征，对于目标数mid，小于它的数总是在其左上方，则我们可以从第1列开始逐列处理，从每一列的最后一个元素开始，如果一个元素小于mid，则计数结果直接把该元素所在列的剩下元素全部都加上，若该元素小于mid，则该列的剩下元素一定小于mid。**这样就避免了多余的遍历**。

~~~python
def kthSmallest(matrix, k):
    def count(mid):#计算不大于mid的矩阵元素数量
        i = len(matrix)
        j = 0#从最后一行的第一列逐列遍历
        num = 0
        while i >= 0 and j < len(matrix):
            if matrix[i][j] > mid:
                i -= 1
            else:
                num += i + 1
                j += 1 
        return num
#循环中，访问元素的位置要不就往上走(i--)，要不往右走(j++)
#正好能访问整个将矩阵分界的边界，左上为不大于目标数，右下为大于目标数
	left, right = matrix[0][0], maxtrix[-1][-1]
    while left < right:
        mid = (left + right) // 2
        num = count(mid)
        if num >= k:
            right = mid
        else:
            left = mid + 1
    return left    
~~~

#### NO.692 前k个高频单词 med 

**排序法**

先利用哈希表来计数，然后以(单词数量, 单词)方式将计数结果存入列表，然后再进行排序。

实际上除了排序，前面的步骤都比较简单，就不提了。

这里排序实际上涉及到一个问题，计数一样的单词，按照字典序来排序，从首字母开始比较字母大小，较小者排前面，首字母若一样，则继续往下比，一方下面没有字母，另一方有，则没字母的排前面。

对于(单词数量，单词)这个数组，单词数量是升序排序，二单词这一维是降序排序。所以单词数量这一栏取-，整个列表进行降序排序，单词数量由于负号相当于进行升序排序，然后再据此输出结果即可。

~~~python
def topKFrequent(self, words, k):
    """
    :type words: List[str]
    :type k: int
    :rtype: List[str]
    """
    wordmap = {}
    wordlist = []
    res = []
    for word in words:
        if word in wordmap:
            wordmap[word] += 1
        else:
            wordmap[word] = 1
    for word, number in wordmap.items():
        wordlist.append((-number, word))
    wordlist.sort()
    res = [wordlist[i][1] for i in range(k)]
        
    return res
~~~



## 2020.8.17 

#### NO.557 反转字符串中的单词 III easy

## 2020.8.18

#### NO.709 转换成小写字母 easy

#### NO.350 两个数组的交集II easy

#### NO.233 矩形面积 med

#### NO.326 3的幂 easy

#### NO.231 2的幂 easy





