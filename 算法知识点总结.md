# 							算法基础总结

## 1 时间复杂度和空间复杂度

**时间复杂度**：当输入数据大小为N时，运行算法所需的操作数量。其描述的是程序运行时间随着输入数据量N增长而变大的趋势。**求的是运行时间的上界，也就是说，假设输入数据量是非常大的情况，来衡量运行时间。**

时间复杂度大概有已下几种：

①O(logN)

②O(N) 线性复杂度

③O(NlogN) 对数复杂度

④O(N^2^) 多项式复杂度

⑤O(1) 常数复杂度

⑥O(2^n^ ) 指数复杂度

⑦O(N)  渐进复杂度

⑧O(N)  均摊复杂度

这几种复杂度看似在表达式上差距不是很大，但是在时间复杂度计算的角度，即时间复杂度衡量的是运行时间的上界，此时N应该是很大的。再回头看这几项复杂度，实际上差距就非常明显了。

所以，从上到下，越往上，时间复杂度越低，算法越优秀，反之亦然。

**常数时间项**：衡量的是**常数操作**的运行时间，这类操作用的时间跟数据量没有关系，计算时间复杂度不考虑常数项。但是，在实际实验中，常数时间也占用了一部分时间。

**如何评价算法流程好坏**：首先看时间复杂度的指标；时间复杂度一样，再比较常数项时间，也就是分析不同数据样本下的实际运行时间。





## 2 排序算法

### 2.1 选择排序、冒泡排序

数组arr[N]

**选择排序**：一共循环N次，第i + 1次循环，得到数组未排序部分（i ~ N - 1）的最小值，并放在数组相应位置arr[i]，时间复杂度O(N^2^)
**冒泡排序**：一共循环N次，第i + 1次循环，从arr[i]开始，对相邻元素进行顺序调整，直到数组末尾，时间复杂度O(N^2^)

### 2.2 插入排序

循环N次，第i次循环，将arr[0] ~ arr[i]部分排序，此时arr[0] ~ arr[i - 1]已经排序完成，只需找到arr[i]的合适位置插入就行。时间复杂度O(N^2^)。特殊情况，接近O(N)。比选择和冒泡这种铁O(N^2^)还是要好一些的。

### 2.3 归并排序

归并排序用到了递归的方法，其思路如下：

将当前数组分为左右两部分，左部分要和右部分进行融合并完成排序，左右部分又分别被分为两部分，递归进行排序。

时间复杂度O(NlogN)，空间复杂度O(N)

### 2.4 堆排序

基于堆数据结构完成的排序。堆就是完全二叉树，其形成的规则就是，其中的任意一棵子树的根节点一定大于其后辈节点，如果是大根堆。小根堆则是根节点一定小于其后辈节点。

排序的思路是：

先把整个数组变成一个小根堆，则头节点最小。将头节点从堆中去除，用堆中最右侧叶子节点代替头节点，进行堆调整，再输出头节点，周而复始，直到堆空。

时间复杂度O(NlogN)

### 2.5 快速排序

快速排序直接说最新版，这涉及到荷兰国旗问题。

快速排序涉及到partition操作，随机选择数组中的一个数，将当前数组分成小于区、大于区以及等于区。

然后分别对小于区、大于区进行partition操作，周而复始。

难点在于如何将一个数组分成小于区，大于区，以及等于区

### 2.6 桶排序

### 2.7 排序算法总结

## 3 堆

## 4 链表

### 4.1 链表解题方法论

①对于笔试，**不用在乎空间复杂度**，一切为了时间复杂度

②对于面试，时间复杂度放在第一位，**但是也要找到空间最省的方法**

重要技巧：

- 额外数据结构记录（栈，队列，哈希表）
- 快慢指针

### 4.2 经典题目

#### 4.2.1 链表的逆序以及回文结构判断



#### 4.2.2 链表的归并排序、以及快速排序



#### 4.2.3 两个单链表相交问题

链表相交问题，需要分情况讨论：

首先对两个单链表的形式进行讨论：

A. 两个单链表中一个带环，一个无环：

​    这两种链表在理论上不可能实现，因为一个节点只有一个next指针，所以两个链表一定不相交

​    a.两个链表完全独立，没有相交

B. 两个单链表都是无环链表

​    两个无环，只有一种相交形式，即开始两个链表独立，从相交点开始，到两个链表尾部，都是共用同一段节点

​    一共两种情况：

​    a.两个链表完全独立，没有相交

​    b.两个链表在某一点相交，并且之后一直共用节点到尾部

C. 两个单链表都是有环链表

​    a.两个链表完全独立，没有相交

​    b.两个链表入环点是同一个

​    c.两个链表入环点不同

## 5 二叉树

### 5.1 二叉树的分类

#### 5.1.1 满二叉树





除了叶子节点，其他所有节点左右孩子双全。

#### 5.1.2 完全二叉树

![img](https://pic3.zhimg.com/80/v2-5fd3c3dd465ad818ab12d8314b4ed346_720w.jpg)

完全二叉树由满二叉树转化而来：将满二叉树从最后一个节点开始，一个个从右往左删除，剩下的就是完全二叉树。

#### 5.1.3 搜索二叉树

![img](https://pic1.zhimg.com/80/v2-fd895b764ad8c4e20bf8ab4492270bb4_720w.jpg)



左子树上所有节点的值均小于它的根节点的值；

右子树上所有节点的值均大于它根节点的值；

左右子树分别也为搜索二叉树。

#### 5.1.4 平衡二叉树(AVL树)



### 5.2 二叉树的遍历

#### 5.2.1 深度优先遍历DFS

#### 5.2.2 广（宽）度优先遍历BFS

#### 5.2.3 先序、中序、后序遍历

### 5.3 二叉树题目

#### 5.3.1 折纸问题

#### 5.3.2 最低公共祖先

#### 5.3.3 二叉树的序列化和反序列化

### 5.4 树形DP

### 5.5 Moris遍历

Moris遍历是对二叉树进行遍历，相比于之前使用的各种遍历算法，该方法的空间复杂度为O(1)，只运用到几个指针就完成整棵数的遍历。

#### Morris遍历细节

 假设来到当前节点cur，开始时cur来到头节点位置 

1）如果cur没有左孩子，cur向右移动(cur = cur.right) 

2）如果cur有左孩子，找到左子树上最右的节点mostRight： 

​	a.如果mostRight的右指针指向空，让其指向cur， 然后cur向左移动(cur = cur.left) 

​	b.如果mostRight的右指针指向cur，让其指向null， 然后cur向右移动(cur = cur.right) 3）cur为空时遍历停止

**先序遍历**：对于叶子节点，直接打印，对于内部节点，打印第一次

**中序遍历**：对于叶子节点，直接打印，对于内部节点，打印第二次

**后序遍历**：

这个有点麻烦。

对于一棵树，1234567

其Morris遍历为**1242513637**

其中123节点是遍历两次的，34567是只遍历一次

在Morris遍历过程中，遇到这些需要访问两次的节点，第一次不做任何操作，第二次则**逆序打印该节点的左树右边界**；而遇到只访问一次的节点，不做任何操作。**最后逆序单独打出整棵树的右边界**。逆序打印可以参考逆序输出链表。



## **6 图**

### 6.1 图结构

图是一种非线性数据结构，有顶点(vertex)和边(edge)组成。图$G$由顶点集$V$和边集$E$组成，记为$G=(V,E)$。

根据边的方向有无，图可分为有向图和无向图。

#### 连通、连通图和连通分量（无向图中讨论）

**连通**：在无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的。

**连通图**：若图G任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。

**极大连通子图**：

- 连通图只有一个极大连通子图，就是它本身
- 非连通图有多个极大连通子图，每个极大连通子图都是一个连通分量

**极小连通子图**：

- 极小连通子图仅存在于连通图（即只有一个连通分量）
- 极小连通子图既要保持图连通又要使得边数最少

#### 强连通图、强连通分量（有向图中讨论）



#### 生成树、生成森林

**生成树**：连通图的生成树是一种特殊的极小连通子图，该极小连通子图包含图中$n$个全部顶点，并且边的数量为$n-1$。一个连通图中的生成树可以有多个。生成树中一定不存在环。

**生成森林**：

#### 图的表达方法

设顶点数量为$n$

- 邻接矩阵
  - 邻接矩阵是$n*n$
  - 邻接矩阵的大小只与节点数量有关，即 $n^2$   。因此，当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费
  - 适合存储稠密图（顶点较少、边较多）
- 邻接表
  - 对于图G中每个顶点都建立一个单链表，表示与该顶点相连的边
  - 邻接表适合存储稀疏图（顶点较多、边较少）



### 6.2 图的遍历

#### 6.2.1 深度优先遍历

#### 1）遍历所有顶点

时间复杂度：



#### 2）遍历两点之间所有路径



#### 6.2.2 广度优先遍历



### 6.3 图的相关应用

#### 6.3.1 拓扑排序算法



#### 6.3.2 最小生成树

**最小生成树**：加权无向图中总权重最小的生成树。最小生成树可以是多个。

#### 切分定理

**切分**：将图切成两个部分，称之为一个切分。

**横切边**：如果一条边连接的两个顶点属于切分的两个部分，这个边成为横切边。

**切分定理**

> 在一幅连通加权无向图中，给定任意切分，如果有一条横切边的权值严格小于其他所有横切边，则这条边必然属于图的最小生成树的一条边

#### $Kruskal$算法

$kruskal$算法是求解加权无向图中的最小生成树的一种算法。

>1. 对所有边按照权重大小进行升序排序
>2. 依次加入最小生成树中（若形成环则跳过，通过并查集$connected()$函数完成）
>3. 直到选择$N-1$条边为止

#### $Prim$算法

$Prim$算法是求解加权无向图中的最小生成树的另一种算法。

>将所有顶点分成两个部分，visited 和 non-visited，最开始，non-visited是整个顶点集，visited为空
>
>初始化：建立集合non-visited包含所有顶点，初始随机选一个点$point$，建立最小堆数组$edges$
>
>1. 将点$point$从non-visited中删除
>2. 遍历点$point$的所有边，逐一插入最小堆数组$edges$中
>3. 从最小堆中弹出权值最小的边，加入生成树中，对应的顶点为$nextpoint$
>4. 点$point=nextpoint$
>5. 重复步骤1~4，直到生成树的边数为$n-1$



#### $Kruskal$算法和$Prim$算法的区别

- $Kruskal$算法通过增加边数来扩大最小生成树
- $Prim$算法中通过增大点数来扩大最小生成树



#### 6.3.3 最短路径

#### $Dijkstra$算法 - 单源最短路径问题





#### $Floyd$算法 - 所有顶点之间的最短距离





#### 6.3.4 关键路径



**对数器**

方法a（想测的方法）

方法b（好实现的暴力方法）

随机样本产生器：方法a → res1 方法b → res2

对比res1和res2，不一样，方法b错了



## 7 回溯法



## 8 前缀树

前缀树是N叉树的一种特殊形式。一个前缀树是用来存储字符串的。前缀树的每个节点代表一个字符串。每个节点的存储的字符串等于其父节点的字符串加上路径上的字符。

<img src="%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/screen-shot-2018-01-31-at-163403.png" alt="img" style="zoom:50%;" />

前缀树一个重要特性是：节点存储的字符串为节点所有后代共同的前缀。

实际应用场景：自动补全，拼写检查

前缀树的表示方法

#### 数组

用数组存储子节点

#### 哈希表

$key=‘a’$，$value=childNode$



## 9 滑动窗口

对于一个数组，窗口左边界和右边界可以向右移动，求窗口在移动中，窗口内数组的实时最大值。

 设置一个**双端队列**：

在对队列进行操作时，始终需要保持队列的单调性，队列**头部大，尾部小**。

#### 当有窗口新元素加入窗口，并加入队列时：

- 新元素小于队列尾部元素（即，最小元素），则从尾部加入新元素；

- 新元素大于队列的尾部元素，则逐个从尾部弹出内部元素（这些元素已经没有价值了，因为这些元素相比于当前新元素，不可能成为最大值，一是内部元素一定早于新元素被移出窗口，二是其值比新元素小），直到满足第一个条件；

#### 当有老元素从窗口中移出，并移出队列时：

​	**查看该元素是否为队列头部元素**

- 若是，则直接从头部弹出该元素；
- 若不是，则队列不操作；

这样的操作，就能够一直保持队列的单调性；

为什么队列能够一直保持这样的信息呢？

双端队列里的信息：

如果目前窗口不再扩大，而选择将左边界一直向右移动，谁会依次成为最大值；弹出元素是因为这些元素已经不可能成为最大值，所以弹出。





## 10 单调栈

> 题目：对于数组中一个数，求其左边和右边比这个数大并且距离其最近的数的位置，如何将时间复杂度降低到O(N)。

比如[3,2,4,2,5,6]，对于数字4来说，其左边没有数字比它大，右边数字5是比它大且离他最近的数字，其位置是4。 

算法步骤：

建立一个单调栈，栈底元素大，栈顶元素小

依次遍历数组中的元素，每次都需要将遍历到的元素加入栈中：

- 当新元素小于栈顶元素，则直接放入栈中
- 当新元素大于栈顶元素，则逐个弹出栈中元素，直到满足单调性为止；并且，此时我们就可以计算弹出的元素的信息，其左侧比他大且最近的数就是在栈中在其下面的数，其右侧比它大且最近的数就是当前要加入栈的新元素。
- 当新元素等于栈顶元素，则直接和栈顶元素形成一个链表，新元素在后，**占用栈的一个空间**，当上方的元素找该单元要信息时，给出先给出右侧元素的信息；若该单元需要弹出元素时，先生成左侧元素的信息，再生成右侧元素的信息。

- 当数组中元素遍历结束了，栈中还有元素没有弹出，则逐个弹出，其左信息就是其下方压着的元素，右信息就是无，因为右侧没有比它大的元素了。





## 11 字符串

### 11.1 $KMP$算法

> 题目：给定字符串$str1$（长度为$n$），$$str2$$（长度为$m$），查看str2是否为str1的子串

暴力方法复杂度：$$O(n*m)$$

$Knuth-Morris-Pratt$字符串查找算法

时间复杂度$O(n+m)$

**$next$数组**

$next[i]$的含义：$str2[:i]$字符串，其前缀和后缀相等的最大长度

举例：$str2="abbabbcd"$

| 位置   | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| $str2$ | a    | b    | b    | a    | b    | b    | c    |
| $next$ | -1   | 0    |      |      |      |      | 3    |

对于$i=6$，$next[i]$的值取决于$str2[:i]$前缀与后缀相等的最大长度

| 前缀后缀的长度 | 1    | 2    | 3    | 4    | 5     |
| -------------- | ---- | ---- | ---- | ---- | ----- |
| 前缀           | a    | ab   | abb  | abba | abbab |
| 后缀           | b    | bb   | abb  | babb | bbabb |
| 是否相等       | 否   | 否   | 是   | 否   | 否    |

对于子串$str2[:6]=abbabb$前缀后缀相等的最大长度为3

#### KMP匹配过程

~~~python
两个指针在两个字符串从左向右移动，逐个对比字符是否相等，指针x为str1的指针，指针y为str2的指针
									x
str1 = [a b b s t k s c a b b s t k s a]
		0							y
str2 = [a b b s t k s c a b b s t k z]
					y
此时x指向's'，y指向'z'，前面的字符全部都相等
我们通过next数组查询字符'z'之前的str2字符串的前后缀相等最大长度为6，对应前后缀为'abbstk'
则指针x不变，指针y跳到字符's',继续比较x和y
~~~

逐个移动指针x和y，发现不一致，查询next数组。

- 若值>=1，则移动指针y，继续比较
- 若值为-1或者0，则说明没有相等前后缀，x指针+1，y指针回到0位置





### 11.2 $Manacher$算法（马拉车）

> 题目：对于字符串$$str$$，其最长回文子串的长度如何求解？

信息数组（回文半径数组）：每一个位置的最长回文半径 （这个数组在很多别的题目也很有用）

#### 概念

- **回文直径**：abba为4，abcba为5

- **回文半径**：abba为2，abcba为2

- **之前扩的所有位置中，所到达的最右回文右边界**$$R$$ 
- **取得最远边界对应的中心** $C$

~~~
R - 之前所扩所有位置中，所到达的最右回文边界
L - 最左侧回文边界
C - 当前最右侧回文边界对应的中心点
i - 当前中心点
i'- 当前中心点关于C的对称点
位置关系如下
[L ... i' ... C ... i ... R]
~~~

对于中心点$i$，我们需要求其回文半径，则我们可以利用区间$[L,R]$的对称性，参考点$i'$的情况：

- 若点$i$在$[L,R]$外侧，则直接包里面扩

- 若点$i$在$[L,R]$内部

  - 若点$i'$的回文范围在$[L,R]$内部，则点$i$的回文半径等于点$i$的回文半径
  - 若点$i'$的回文范围在$[L,R]$外部，则点$i$的回文半径为$i$到$R$
  - 若点$i'$的回文左边界和$L$重合，则$i$到$R$一定回文，但需要从$R$继续外扩

  

先对字符str进行预处理，插入#

$str = ‘abc’ → str' = '#a#b#c#'

加入#的目的是处理那些长度为偶数，对称轴是虚的回文串的情况。

对于str‘，建立信息数组，每个元素保存以当前字符为中心的最长回文字符串的半径长度。



## 12 并查集 $Union Find$

并查集的主要作用是用来解决网络中的连通性。

### 并查集常用术语

**父节点**

**根节点**：父节点为本身的节点。作为一个集合的代表。

![5. Connected.png](%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/1625376950-kzcwDc-5.%20Connected.png)

 

>$root$数组
>
>| **父节点** | 0    | 0    | 0    | 1    | 4    | 5    | 5    | 5    | 4    | 9    |
>| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
>| **索引**   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
>
>通过维护$root$数组完成并查集数据结构

#### 并查集有两个核心函数：$union()$代表“并”，$find()$代表”查“

- $union(a,b)$将两个元素对应的集合合并
  - 设$a$为这次合并的父节点，则我们直接将$b$的根节点的父节点设置为$a$（直接修改$root$数组对应元素），则完成了$a$所属集合与$b$所属集合的合并，新的大集合的根节点为原本$a$所属集合的父节点
  - 反之亦然
- $find(a)$找到给定元素的根节点
- $connected(a,b)$查看两个元素是否属于同一集合，或两个元素的根节点是否相同，或两个元素在图中是否连通
  - 查看元素$a$所属元素的根节点与元素$b$所属集合的根节点是否相同
  - 若相同，则$a$和$b$属于同一个集合，返回$True$
  - 若不同，则$a$和$b$不属于同一个集合，返回$False$

### 并查集的三个实现方式

#### $Quick Find$

>它指的是实现「并查集」时，$find$ 函数时间复杂度很低为 $O(1)$，但对应的 $union$ 函数就需要承担更多的责任，它的时间复杂度为 $O(N)$。
>
>**$root$数组存储的是根节点**

~~~python
class QuickFind:
	def __init__(self,size):
        self.root = [i for i in range(size)]
        
    def find(self,x):
        return self.root[x] # 直接返回顶点x对应的根节点
    
    def union(self,x,y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            # 将rootY下面的所有节点都移到rootX旗下
            # O(n)复杂度
            for i in range(len(self.root)):
                if self.root[i] == rootY:
                    self.root[i] = rootX
   	def connected(self,x,y):
        return self.find(x) == self.find(y)
~~~

#### $Quick Union$

>它指的是实现「并查集」时，相对于 $Quick Find$ 的实现方式，我们通过降低 $union$ 函数的职责来提高它的效率，但同时，我们也增加了 $find$ 函数的职责。

> root数组中**存储的是父节点而不是根节点**

~~~python
class QuickUnion:
	def __init__(self,size):
        self.root = [i for i in range(size)]
        
    def find(self,x):
        while self.root[x] != x:
            x = self.root[x]
        return x
    
    def union(self,x,y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            self.root[rootY] = rootX
    
    def connected(self.x,y):
        return self.find(x) == self.find(y)        
~~~

$QuickUnion$比$QuickFind$在整体上更高效

#### 按秩合并的并查集

针对最差情况，即链表状的图，有解决办法防止时间复杂度退化到$O(n^2)$吗？

之前在进行`union`的时候，我们随机分配父节点。在`按秩合并`的方法中，我们按照某种秩序选择父节点。

这里的`秩`指的是`每个顶点所处的高度`。我们每次union两个顶点的时候，我们选择将`秩`大的节点作为父节点

~~~python
class UnionFind:
    def __init__(self,size):
        self.root = [i for i in range(size)]
        self.rank = [1 for _ in range(size)]
    
    def find(self,x):
        while self.root[x] != x:
            x = self.root[x]
        return x
    
    def union(self,x,y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            if self.rank[rootX] > self.rank[rootY]:
                self.root[rootY] = rootX
            elif self.rank[rootY] > self.rank[rootX]:
                self.root[rootX] = rootY
            else:
                self.root[rootY] = rootX
                self.rank[rootX] += 1
                
    def connected(self,x,y):
        return self.find(x) == self.find(y)
~~~

### 路径压缩优化的并查集

路径压缩优化是针对$QuickUnion$的`find()`函数进行优化

对于下面的一个并查集结构：

> 0 - 1 - 2 - 3 - 4 - 5

0是根节点，5是最底层节点，当我们使用`find(5)`函数，我们会从5一直往上找5次才能找到根节点。我们在从底层往上走的过程中，中间的节点`4321`他们的根节点也是0，那么更新了节点5的父节点，那么我们可以顺便将路径上节点的根节点一同更新。在这里，我们通过递归的方法进行逐层更新。

~~~python
# 路径压缩，按秩合并，Quick Union 并查集
class UnionFind:
    def __init__(self,size):
        self.root = [i for i in range(size)]
        self.rank = [1 for _ in range(size)] # 秩代表节点高度，根节点最高，秩最大
    
    def find(self,x):
        if self.root[x] == x:
            return x
        self.root[x] = self.find(root[x])
        return self.root[x]
    
    def union(self,x,y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            if self.rank[rootX] > self.rank[rootY]:
                self.root[rootY] = rootX
            elif self.rank[rootY] > self.rank[rootX]:
                self.root[rootX] = rootY
            else:
                self.root[rootY] = rootX
                self.rank[rootX] += 1
                
    def connected(self,x,y):
        return self.find(x) == self.find(y)        
~~~



### 时间复杂度比较

|              | 构造函数 | $Union()$    | $Find()$     |
| ------------ | -------- | ------------ | ------------ |
| $Quick Find$ | $O(n)$   | $O(n)$       | $O(1)$       |
| $QuickUnion$ | $O(n)$   | $O(H)<=O(n)$ | $O(H)<=O(n)$ |
| 按秩合并     | $O(n)$   | $O(logn)$    | $O(logn)$    |

$H$为树的高度，$n$个图中顶点的个数，$QuickUnion$的最差情况是当树为链表状，$H==n$

连接$n$个元素，$QuickUnion$的最差时间复杂度是$O(n^2)$，$QuickFind$的时间复杂度是$O(n^2)$，$QuickFind$要稍微好一些。总体上来说，比较这两个方法相当于矮子里面拔将军，都一般。基于$QuickUnion$的按秩合并防止了链表状的树出现，使得树的高度稳定在$H=logn$。

## 13 有序表

有序表可以理解成有顺序关系的哈希表。

有序表的最原始的形式是严格平衡搜索二叉树，但是有序表不是严格的平衡，而是广义的平衡。

Balanced Search Tree(BST) 平衡搜索二叉树分类：

- 红黑树
- AVL树 严格平衡
- Size Balanced Tree(SB)树
- Skip list 跳表 单链表

### 1.树的左旋和右旋

树进行左旋和右旋的目的是对搜索树进行平衡化。

### 2.AVL树

### 3.SB树

### 4.红黑树



## 14 栈和队列

### 14.1 栈

栈是先进后出，先进入栈的元素被压入栈底，最后进的元素在栈顶。

用python list对象实现

弹出操作 pop(): 弹出栈顶元素，并返回

插入操作push():将元素压入栈顶

显示栈顶top():返回栈顶元素

### 14.2 队列

队列是先进先出











## 如何将三个月经历包装成三年

### 1.简历怎么写

技能清单：



项目经历：

不要写太多业务。突出用了什么技术，技术的特性。技术为重点。

1）先去云平台去熟悉好用的技术工具（AWS，阿里云），看工具，分析其为什么好

5 - 6很火的概念，15天

2）找到开源的对应产品，调研所选的产品，开始猛学，两个月，自己搭一下

3）编业务



个人评价：

重点介绍对于技术看法。