# 算法基础总结

## 1 时间复杂度和空间复杂度

**时间复杂度**：用来衡量程序运行时间随着输入数据量增长而变大的趋势。**求的是运行时间的上界，也就是说，假设输入数据量是非常大的情况，来衡量运行时间。**

时间复杂度大概有已下几种：

①O(logN)

②O(N)

③O(NlogN)

④O(N^2^)

这几种复杂度看似在表达式上差距不是很大，但是在时间复杂度计算的角度，即时间复杂度衡量的是运行时间的上界，此时N应该是很大的。再回头看这几项复杂度，实际上差距就非常明显了。

所以，从上到下，越往上，时间复杂度越低，算法越优秀，反之亦然。

**常数时间项**：衡量的是**常数操作**的运行时间，这类操作用的时间跟数据量没有关系，计算时间复杂度不考虑常数项。但是，在实际实验中，常数时间也占用了一部分时间。

**如何评价算法流程好坏**：首先看时间复杂度的指标；时间复杂度一样，再比较常数项时间，也就是分析不同数据样本下的实际运行时间。

## 2 排序算法

### 2.1 选择排序、冒泡排序

数组arr[N]

**选择排序**：一共循环N次，第i + 1次循环，得到数组未排序部分（i ~ N - 1）的最小值，并放在数组相应位置arr[i]，时间复杂度O(N^2^)
**冒泡排序**：一共循环N次，第i + 1次循环，从arr[i]开始，对相邻元素进行顺序调整，直到数组末尾，时间复杂度O(N^2^)

### 2.2 插入排序

循环N次，第i次循环，将arr[0] ~ arr[i]部分排序，此时arr[0] ~ arr[i - 1]已经排序完成，只需找到arr[i]的合适位置插入就行。时间复杂度O(N^2^)。特殊情况，接近O(N)。比选择和冒泡这种铁O(N^2^)还是要好一些的。

### 2.3 归并排序

归并排序用到了递归的方法，其思路如下：

将当前数组分为左右两部分，左部分要和右部分进行融合并完成排序，左右部分又分别被分为两部分，递归进行排序。

时间复杂度O(NlogN)，空间复杂度O(N)

### 2.4 堆排序

基于堆数据结构完成的排序。堆就是完全二叉树，其形成的规则就是，其中的任意一棵子树的根节点一定大于其后辈节点，如果是大根堆。小根堆则是根节点一定小于其后辈节点。

排序的思路是：

先把整个数组变成一个小根堆，则头节点最小。将头节点从堆中去除，用堆中最右侧叶子节点代替头节点，进行堆调整，再输出头节点，周而复始，直到堆空。

时间复杂度O(NlogN)

### 2.5 快速排序

快速排序直接说最新版，这涉及到荷兰国旗问题。

快速排序涉及到partition操作，随机选择数组中的一个数，将当前数组分成小于区、大于区以及等于区。

然后分别对小于区、大于区进行partition操作，周而复始。

难点在于如何将一个数组分成小于区，大于区，以及等于区

### 2.6 桶排序

### 2.7 排序算法总结

## 3 堆

## 4 链表

### 4.1 链表解题方法论

①对于笔试，**不用在乎空间复杂度**，一切为了时间复杂度

②对于面试，时间复杂度放在第一位，**但是也要找到空间最省的方法**

重要技巧：

- 额外数据结构记录（栈，队列，哈希表）
- 快慢指针

### 4.2 经典题目

#### 4.2.3 两个单链表相交问题

链表相交问题，需要分情况讨论：

首先对两个单链表的形式进行讨论：

一、两个单链表中一个带环，一个无环：

​    这两种链表在理论上不可能实现，因为一个节点只有一个next指针，所以两个链表一定不相交

​    a.两个链表完全独立，没有相交

二、两个单链表都是无环链表

​    两个无环，只有一种相交形式，即开始两个链表独立，从相交点开始，到两个链表尾部，都是共用同一段节点

​    一共两种情况：

​    a.两个链表完全独立，没有相交

​    b.两个链表在某一点相交，并且之后一直共用节点到尾部

三、两个单链表都是有环链表

​    a.两个链表完全独立，没有相交

​    b.两个链表入环点是同一个

​    c.两个链表入环点不同





## 5 二叉树

### 5.1 二叉树的分类

#### 5.1.1 满二叉树

#### 5.1.2 完全二叉树

#### 5.1.3 搜索二叉树

#### 5.1.4 平衡二叉树(AVL树)







### 5.2 二叉树的遍历

#### 5.2.1 深度优先遍历DFS

#### 5.2.2 广（宽）度优先遍历BFS

#### 5.2.3 先序、中序、后序遍历

### 5.3 二叉树题目

#### 5.3.1 折纸问题

#### 5.3.2 最低公共祖先

#### 5.3.3 二叉树的序列化和反序列化





## 6 图

### 6.1图结构

### 6.2 图的遍历

### 6.3 图的算法

#### 6.3.1 拓扑排序算法

#### 6.3.2 最小生成树

6.3.2.1 kruskal算法

6.3.2.2 prim算法

#### 6.3.3 单元最短距离算法







**对数器**

方法a（想测的方法）

方法b（好实现的暴力方法）

随机样本产生器：方法a → res1 方法b → res2

对比res1和res2，不一样，方法b错了



## 7 回溯法



## 8 前缀树



